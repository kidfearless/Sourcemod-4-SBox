/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2009-2013 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 */

using System;
using System.Collections.ObjectModel;
namespace Sourcemod
{
	public partial class SourceMod
	{

// this is obviously _not_ a robust check, but it will solve most conflict and is clean
#if !defined DMG_GENERIC
public const object DMG_GENERIC                  0          /**< generic damage was done */
public const object DMG_CRUSH                   (1 << 0)    /**< crushed by falling or moving object.
                                                     NOTE: It's assumed crush damage is occurring as a result of physics collision,
                                                     so no extra physics force is generated by crush damage.
                                                     DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics
                                                     collision. You probably want DMG_CLUB instead. */
public const object DMG_BULLET                  (1 << 1)    /**< shot */
public const object DMG_SLASH                   (1 << 2)    /**< cut, clawed, stabbed */
public const object DMG_BURN                    (1 << 3)    /**< heat burned */
public const object DMG_VEHICLE                 (1 << 4)    /**< hit by a vehicle */
public const object DMG_FALL                    (1 << 5)    /**< fell too far */
public const object DMG_BLAST                   (1 << 6)    /**< explosive blast damage */
public const object DMG_CLUB                    (1 << 7)    /**< crowbar, punch, headbutt */
public const object DMG_SHOCK                   (1 << 8)    /**< electric shock */
public const object DMG_SONIC                   (1 << 9)    /**< sound pulse shockwave */
public const object DMG_ENERGYBEAM              (1 << 10)   /**< laser or other high energy beam  */
public const object DMG_PREVENT_PHYSICS_FORCE   (1 << 11)   /**< Prevent a physics force  */
public const object DMG_NEVERGIB                (1 << 12)   /**< with this bit OR'd in, no damage type will be able to gib victims upon death */
public const object DMG_ALWAYSGIB               (1 << 13)   /**< with this bit OR'd in, any damage type can be made to gib victims upon death. */
public const object DMG_DROWN                   (1 << 14)   /**< Drowning */
public const object DMG_PARALYZE                (1 << 15)   /**< slows affected creature down */
public const object DMG_NERVEGAS                (1 << 16)   /**< nerve toxins, very bad */
public const object DMG_POISON                  (1 << 17)   /**< blood poisoning - heals over time like drowning damage */
public const object DMG_RADIATION               (1 << 18)   /**< radiation exposure */
public const object DMG_DROWNRECOVER            (1 << 19)   /**< drowning recovery */
public const object DMG_ACID                    (1 << 20)   /**< toxic chemicals or acid burns */
public const object DMG_SLOWBURN                (1 << 21)   /**< in an oven */
public const object DMG_REMOVENORAGDOLL         (1 << 22)   /**< with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
                                                     use this to kill an entity that you've already got a server-side ragdoll for */
public const object DMG_PHYSGUN                 (1 << 23)   /**< Hit by manipulator. Usually doesn't do any damage. */
public const object DMG_PLASMA                  (1 << 24)   /**< Shot by Cremator */
public const object DMG_AIRBOAT                 (1 << 25)   /**< Hit by the airboat's gun */
public const object DMG_DISSOLVE                (1 << 26)   /**< Dissolving! */
public const object DMG_BLAST_SURFACE           (1 << 27)   /**< A blast on the surface of water that cannot harm things underwater */
public const object DMG_DIRECT                  (1 << 28)
public const object DMG_BUCKSHOT                (1 << 29)   /**< not quite a bullet. Little, rounder, different. */
#endif

#if !defined DMG_CRIT
	#define DMG_CRIT                DMG_ACID        /**< TF2 crits and minicrits */
#endif

#if !defined DMG_RADIUS_MAX
	#define DMG_RADIUS_MAX          DMG_ENERGYBEAM  /**< No damage falloff */
#endif

#if !defined DMG_NOCLOSEDISTANCEMOD
	#define DMG_NOCLOSEDISTANCEMOD  DMG_POISON      /**< Don't do damage falloff too close */
#endif

#if !defined DMG_HALF_FALLOFF
	#define DMG_HALF_FALLOFF        DMG_RADIATION   /**< 50% damage falloff */
#endif

#if !defined DMG_USEDISTANCEMOD
	#define DMG_USEDISTANCEMOD      DMG_SLOWBURN    /**< Do damage falloff */
#endif

#if !defined DMG_IGNITE
	#define DMG_IGNITE              DMG_PLASMA      /**< Ignite victim */
#endif

#if !defined DMG_USE_HITLOCATIONS
	#define DMG_USE_HITLOCATIONS    DMG_AIRBOAT     /**< Do hit location damage (Like the sniperrifle and ambassador) */
#endif

public enum SDKHookType
{
	SDKHook_EndTouch,
	SDKHook_FireBulletsPost,
	SDKHook_OnTakeDamage,
	SDKHook_OnTakeDamagePost,
	SDKHook_PreThink,
	SDKHook_PostThink,
	SDKHook_SetTransmit,
	SDKHook_Spawn,
	SDKHook_StartTouch,
	SDKHook_Think,
	SDKHook_Touch,
	SDKHook_TraceAttack,
	SDKHook_TraceAttackPost,
	SDKHook_WeaponCanSwitchTo,
	SDKHook_WeaponCanUse,
	SDKHook_WeaponDrop,
	SDKHook_WeaponEquip,
	SDKHook_WeaponSwitch,
	SDKHook_ShouldCollide,
	SDKHook_PreThinkPost,
	SDKHook_PostThinkPost,
	SDKHook_ThinkPost,
	SDKHook_EndTouchPost,
	SDKHook_GroundEntChangedPost,
	SDKHook_SpawnPost,
	SDKHook_StartTouchPost,
	SDKHook_TouchPost,
	SDKHook_VPhysicsUpdate,
	SDKHook_VPhysicsUpdatePost,
	SDKHook_WeaponCanSwitchToPost,
	SDKHook_WeaponCanUsePost,
	SDKHook_WeaponDropPost,
	SDKHook_WeaponEquipPost,
	SDKHook_WeaponSwitchPost,
	SDKHook_Use,
	SDKHook_UsePost,
	SDKHook_Reload,
	SDKHook_ReloadPost,
	SDKHook_GetMaxHealth,  /**< ep2v and later */
	SDKHook_Blocked,
	SDKHook_BlockedPost,
	SDKHook_OnTakeDamageAlive,
	SDKHook_OnTakeDamageAlivePost,
	SDKHook_CanBeAutobalanced
};

/*
	Alphabetized for easy readability

	SDKHook_Blocked,
	SDKHook_BlockedPost,

	SDKHook_CanBeAutobalanced,

	SDKHook_EndTouch,
	SDKHook_EndTouchPost,

	SDKHook_FireBulletsPost,

	SDKHook_GetMaxHealth,  (ep2v and later)

	SDKHook_GroundEntChangedPost,

	SDKHook_OnTakeDamage,
	SDKHook_OnTakeDamagePost,

	SDKHook_OnTakeDamageAlive,
	SDKHook_OnTakeDamageAlivePost,

	SDKHook_PreThink,
	SDKHook_PreThinkPost,

	SDKHook_PostThink,
	SDKHook_PostThinkPost,

	SDKHook_Reload,
	SDKHook_ReloadPost,

	SDKHook_SetTransmit,

	SDKHook_ShouldCollide,

	SDKHook_Spawn,
	SDKHook_SpawnPost,

	SDKHook_StartTouch,
	SDKHook_StartTouchPost,

	SDKHook_Think,
	SDKHook_ThinkPost,

	SDKHook_Touch,
	SDKHook_TouchPost,

	SDKHook_TraceAttack,
	SDKHook_TraceAttackPost,

	SDKHook_Use,
	SDKHook_UsePost,

	SDKHook_VPhysicsUpdate,
	SDKHook_VPhysicsUpdatePost,

	SDKHook_WeaponCanSwitchTo,
	SDKHook_WeaponCanSwitchToPost,

	SDKHook_WeaponCanUse,
	SDKHook_WeaponCanUsePost,

	SDKHook_WeaponDrop,
	SDKHook_WeaponDropPost,

	SDKHook_WeaponEquip,
	SDKHook_WeaponEquipPost,

	SDKHook_WeaponSwitch,
	SDKHook_WeaponSwitchPost
*/

public enum UseType
{
	Use_Off,
	Use_On,
	Use_Set,
	Use_Toggle
};

typeset SDKHookCB
{
	// PreThink/Post
	// PostThink/Post
	function void (int client) { throw new NotImplementedException(); }

	// Spawn
	function Action (int entity) { throw new NotImplementedException(); }

	// GroundEntChanged
	// SpawnPost
	// Think/Post
	// VPhysicsUpdate/Post
	function void (int entity) { throw new NotImplementedException(); }

	// EndTouch
	// StartTouch
	// Touch
	// Blocked
	function Action (int entity, int other) { throw new NotImplementedException(); }

	// EndTouchPost
	// StartTouchPost
	// TouchPost
	function void (int entity, int other) { throw new NotImplementedException(); }

	// SetTransmit
	function Action (int entity, int client) { throw new NotImplementedException(); }

	// WeaponCanSwitchTo
	// WeaponCanUse
	// WeaponDrop
	// WeaponEquip
	// WeaponSwitch
	function Action (int client, int weapon) { throw new NotImplementedException(); }

	// WeaponCanSwitchToPost
	// WeaponCanUsePost
	// WeaponDropPost
	// WeaponEquipPost
	// WeaponSwitchPost
	function void (int client, int weapon) { throw new NotImplementedException(); }

	// GetMaxHealth (ep2v and later)
	function Action (int entity, int &maxhealth) { throw new NotImplementedException(); }

	// OnTakeDamage
	// OnTakeDamageAlive
	// SDKHooks 1.0+
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype) { throw new NotImplementedException(); }

	// OnTakeDamage
	// OnTakeDamageAlive
	// Note: The weapon parameter is not used by all games and damage sources.
	// Note: Force application is dependent on game and damage type(s)
	// SDKHooks 2.0+
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3]) { throw new NotImplementedException(); }

	// OnTakeDamage
	// OnTakeDamageAlive
	// Note: The weapon parameter is not used by all games and damage sources.
	// Note: Force application is dependent on game and damage type(s)
	// SDKHooks 2.1+  (can check for support at runtime using GetFeatureStatus on SDKHook_DmgCustomInOTD capability.
	// DON'T attempt to access 'damagecustom' var if feature status != available
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon,
		float damageForce[3], float damagePosition[3], int damagecustom) { throw new NotImplementedException(); }

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype) { throw new NotImplementedException(); }

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int weapon, ReadOnlyCollection<float> damageForce[3], ReadOnlyCollection<float> damagePosition[3]) { throw new NotImplementedException(); }

	// OnTakeDamagePost
	// OnTakeDamageAlivePost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int weapon,
		ReadOnlyCollection<float> damageForce[3], ReadOnlyCollection<float> damagePosition[3], int damagecustom) { throw new NotImplementedException(); }

	// FireBulletsPost
	function void (int client, int shots, string weaponname) { throw new NotImplementedException(); }

	// TraceAttack
	function Action (int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &ammotype, int hitbox, int hitgroup) { throw new NotImplementedException(); }

	// TraceAttackPost
	function void (int victim, int attacker, int inflictor, float damage, int damagetype, int ammotype, int hitbox, int hitgroup) { throw new NotImplementedException(); }

	// ShouldCollide
	function bool (int entity, int collisiongroup, int contentsmask, bool originalResult) { throw new NotImplementedException(); }

	// Use
	function Action (int entity, int activator, int caller, UseType type, float value) { throw new NotImplementedException(); }

	// UsePost
	function void (int entity, int activator, int caller, UseType type, float value) { throw new NotImplementedException(); }

	// Reload
	function Action (int weapon) { throw new NotImplementedException(); }

	// Reload post
	function void (int weapon, bool bSuccessful) { throw new NotImplementedException(); }

	// CanBeAutobalanced
	function bool (int client, bool origRet) { throw new NotImplementedException(); }
};


/**
 * When an entity is created
 *
 * @param entity        Entity index
 * @param classname     Class name
 */
public static virtual void OnEntityCreated(int entity, string classname) { throw new NotImplementedException(); }

/**
 * When an entity is spawned
 *
 * @param entity        Entity index
 * @param classname     Class name
 *
 * @note Check for support at runtime using GetFeatureStatus on SDKHook_OnEntitySpawned capability.
 */
public static virtual void OnEntitySpawned(int entity, string classname) { throw new NotImplementedException(); }

/**
 * When an entity is destroyed
 *
 * @param entity        Entity index or edict reference.
 */
public static virtual void OnEntityDestroyed(int entity) { throw new NotImplementedException(); }

/**
 * When the game description is retrieved
 *
 * @note Not supported on ep2v.
 *
 * @param gameDesc      Game description
 * @return              Plugin_Changed if gameDesc has been edited, else no change.
 */
public static virtual Action OnGetGameDescription(char gameDesc[64]) { throw new NotImplementedException(); }

/**
 * When the level is initialized
 *
 * @param mapName       Name of the map
 * @param mapEntities   Entities of the map
 * @return              Plugin_Changed if mapEntities has been edited, else no change.
 */
public static virtual Action OnLevelInit(string mapName, char mapEntities[2097152]) { throw new NotImplementedException(); }

/**
 * Hooks an entity
 *
 * @param entity        Entity index
 * @param type          Type of function to hook
 * @param callback      Function to call when hook is called
 */
public static void SDKHook(int entity, SDKHookType type, SDKHookCB callback) { throw new NotImplementedException(); }

/**
 * Hooks an entity
 *
 * @param entity        Entity index
 * @param type          Type of function to hook
 * @param callback      Function to call when hook is called
 * @return              Hook Successful
 */
public static bool SDKHookEx(int entity, SDKHookType type, SDKHookCB callback) { throw new NotImplementedException(); }

/**
 * Unhooks an entity
 *
 * @param entity   Entity index
 * @param type     Type of function to unhook
 * @param callback Callback function to unhook
 */
public static void SDKUnhook(int entity, SDKHookType type, SDKHookCB callback) { throw new NotImplementedException(); }

/**
 * Applies damage to an entity
 *
 * @note Force application is dependent on game and damage type(s)
 *
 * @param entity         Entity index taking damage
 * @param inflictor      Inflictor entity index
 * @param attacker       Attacker entity index
 * @param damage         Amount of damage
 * @param damageType     Bitfield of damage types
 * @param weapon         Weapon index (orangebox and later) or -1 for unspecified
 * @param damageForce    Velocity of damage force
 * @param damagePosition Origin of damage
 */
public static void SDKHooks_TakeDamage(int entity, int inflictor, int attacker,
		float damage, int damageType=DMG_GENERIC, int weapon=-1,
		ReadOnlyCollection<float> damageForce[3]=NULL_VECTOR, ReadOnlyCollection<float> damagePosition[3]=NULL_VECTOR) { throw new NotImplementedException(); }

/**
 * Forces a client to drop the specified weapon
 *
 * @param client        Client index.
 * @param weapon        Weapon entity index.
 * @param vecTarget     Location to toss weapon to, or NULL_VECTOR for default.
 * @param vecVelocity   Velocity at which to toss weapon, or NULL_VECTOR for default.
 * @error               Invalid client or weapon entity, weapon not owned by client.
 */
public static void SDKHooks_DropWeapon(int client, int weapon, ReadOnlyCollection<float> vecTarget[3]=NULL_VECTOR,
		ReadOnlyCollection<float> vecVelocity[3]=NULL_VECTOR) { throw new NotImplementedException(); }

/**
 * Do not edit below this line!
 */
public Extension __ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
#if defined AUTOLOAD_EXTENSIONS
	autoload = 1,
#else
	autoload = 0,
#endif
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};
	}
}